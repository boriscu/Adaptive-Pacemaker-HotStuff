<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HotStuff Simulation</title>
    <style>
        body { font-family: sans-serif; padding: 20px; background: #f4f4f4; }
        .dashboard { display: flex; flex-direction: column; gap: 20px; }
        .panel { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        h1 { margin-top: 0; }
        .controls button { padding: 10px 15px; margin-right: 10px; cursor: pointer; }
        .metrics { margin-top: 20px; }
        .replica-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-top: 20px; }
        .replica-card { border: 1px solid #ccc; padding: 10px; border-radius: 4px; background: #fff; }
        .replica-card.leader { border-color: gold; border-width: 2px; }
        .stat-val { font-weight: bold; }
    </style>
</head>
<body>

    <h1>HotStuff Consensus Simulation</h1>

    <div class="dashboard">
        <div class="panel">
            <h2>Controls</h2>
            <div class="controls">
                <button onclick="control('start')" style="background: #e1ffe1;">Start</button>
                <button onclick="control('stop')" style="background: #ffe1e1;">Stop</button>
                <button onclick="control('reset')">Reset</button>
            </div>
            
            <h3>Configuration</h3>
            <label>N: <input type="number" id="confN" value="4" style="width: 50px;"></label>
            <label>F: <input type="number" id="confF" value="1" style="width: 50px;"></label>
            <label>Protocol: 
                <select id="confProto">
                    <option value="CHAINED">Chained</option>
                    <option value="BASIC">Basic</option>
                </select>
            </label>
                </select>
            </label>
            <button onclick="updateConfig()">Apply</button>
            
            <div style="margin-top: 15px;">
                <label>Speed (Delay): <span id="speedVal">2.5</span>s</label>
                <input type="range" id="speedSlider" min="0.1" max="5.0" step="0.1" value="2.5" oninput="updateSpeed(this.value)" style="width: 100%;">
                <div style="display: flex; justify-content: space-between; font-size: 0.8em; color: #666;">
                    <span>Fast</span>
                    <span>Slow</span>
                </div>
            </div>

            <div class="metrics">
                <h3>Metrics</h3>
                <p>Time: <span id="simTime" class="stat-val">0.0</span></p>
                <p>Committed Blocks: <span id="totalCommitted" class="stat-val">0</span></p>
                <p>Avg Latency: <span id="avgLatency" class="stat-val">0.0</span> ms</p>
                <p>View Changes: <span id="viewChanges" class="stat-val">0</span></p>
            </div>
        </div>

        <div class="panel">
            <h2>Replicas Topology</h2>
            <div id="canvasContainer" style="text-align: center;">
                <canvas id="topoCanvas" width="1000" height="600" style="border:1px solid #ddd; background: white; border-radius: 4px;"></canvas>
            </div>
        </div>
    </div>

    <script>
        function control(action) {
            fetch('/api/control', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({action: action})
            });
        }

        function updateConfig() {
            fetch('/api/config', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    N: document.getElementById('confN').value,
                    F: document.getElementById('confF').value,
                    PROTOCOL: document.getElementById('confProto').value
                })
            }).then(() => control('reset'));
        }

        function updateSpeed(val) {
            document.getElementById('speedVal').innerText = val;
            fetch('/api/speed', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({delay: val})
            });
        }

        // Particle System
        const particles = [];

        function updateParticles(width, height) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.progress += 0.02; // Speed of animation (frames)
                
                if (p.progress >= 1.0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles(ctx, nodesMap) {
            particles.forEach(p => {
                const srcNode = nodesMap[p.src];
                const dstNode = nodesMap[p.dst];
                
                if (!srcNode || !dstNode) return;
                
                const x = srcNode.x + (dstNode.x - srcNode.x) * p.progress;
                const y = srcNode.y + (dstNode.y - srcNode.y) * p.progress;
                
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                
                // Color by type
                if (p.type === 'NEW_VIEW') ctx.fillStyle = 'blue';
                else if (p.type === 'PREPARE') ctx.fillStyle = 'yellow';
                else if (p.type === 'PRE_COMMIT') ctx.fillStyle = 'orange';
                else if (p.type === 'COMMIT') ctx.fillStyle = 'green';
                else if (p.type === 'DECIDE') ctx.fillStyle = 'purple';
                else if (p.type === 'VOTE') ctx.fillStyle = '#00CED1'; // DarkTurquoise
                else ctx.fillStyle = 'black';
                
                ctx.fill();
            });
        }

        // We need an animation loop independent of the 500ms status fetch
        // Status fetch adds particles, animation loop draws them.
        
        let currentReplicas = {}; 
        
        function animate() {
            const canvas = document.getElementById('topoCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Re-draw everything (topology + particles)
            drawFrame(ctx, width, height);
            
            updateParticles(width, height);
            requestAnimationFrame(animate);
        }
        
        // Start animation loop
        requestAnimationFrame(animate);

        function drawFrame(ctx, width, height) {
             const cx = width / 2;
             const cy = height / 2;
             
             // Clear
             ctx.clearRect(0, 0, width, height);
             
             const ids = Object.keys(currentReplicas).sort();
             const N = ids.length;
             
             if (N === 0) return;

             const radius = Math.min(width, height) / 2 - 80;
             const nodes = [];
             const nodesMap = {};
             
             // Calculate positions
             ids.forEach((rid, i) => {
                 const angle = (2 * Math.PI * i) / N - Math.PI / 2;
                 const n = {
                     id: rid,
                     x: cx + radius * Math.cos(angle),
                     y: cy + radius * Math.sin(angle),
                     data: currentReplicas[rid]
                 };
                 nodes.push(n);
                 nodesMap[rid] = n;
             });

            // Draw edges
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i < N; i++) {
                for (let j = i + 1; j < N; j++) {
                    ctx.beginPath();
                    ctx.moveTo(nodes[i].x, nodes[i].y);
                    ctx.lineTo(nodes[j].x, nodes[j].y);
                    ctx.stroke();
                }
            }

            // Draw Particles
            drawParticles(ctx, nodesMap);

            // Draw nodes
            nodes.forEach(node => {
                const r = node.data;
                // Circle
                ctx.beginPath();
                ctx.arc(node.x, node.y, 45, 0, 2 * Math.PI);
                ctx.fillStyle = '#fff';
                
                 if (r.is_faulty) {
                    ctx.fillStyle = '#ffebee';
                    ctx.strokeStyle = '#d32f2f';
                } else if (r.is_leader) {
                    ctx.fillStyle = '#fff8e1'; 
                    ctx.strokeStyle = '#ffa000';
                } else {
                    ctx.fillStyle = '#fff';
                    ctx.strokeStyle = '#666';
                }
                
                ctx.fill();
                ctx.lineWidth = r.is_leader ? 4 : 2;
                ctx.stroke();
                
                if (r.is_leader) {
                    ctx.font = '20px serif';
                    ctx.fillText('ðŸ‘‘', node.x, node.y - 35);
                } else if (r.is_faulty) {
                     ctx.font = '20px serif';
                     ctx.fillText('ðŸ’€', node.x, node.y - 35);
                }
                
                ctx.fillStyle = '#000';
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`R${node.id}`, node.x, node.y - 10);

                ctx.font = '12px sans-serif';
                ctx.fillText(`View: ${r.view}`, node.x, node.y + 10);
                
                // Show Phase instead of Height (or both)
                ctx.fillStyle = '#0055ff';
                ctx.fillText(r.phase || "", node.x, node.y + 24);

                if (r.last_commit) {
                     ctx.fillStyle = '#444';
                     ctx.fillText(r.last_commit.substring(0,6), node.x, node.y + 38);
                }
            });
        }
        
        // No longer called directly for drawing, just updates state
        function drawTopology(replicas) {
             currentReplicas = replicas;
        }

        function updateDashboard() {
            fetch('/api/status')
            .then(res => res.json())
            .then(data => {
                document.getElementById('simTime').innerText = data.time.toFixed(2);
                document.getElementById('totalCommitted').innerText = data.metrics.total_committed;
                document.getElementById('avgLatency').innerText = data.metrics.avg_latency.toFixed(4);
                document.getElementById('viewChanges').innerText = data.metrics.view_changes;

                // Update Replicas Data
                drawTopology(data.replicas);
                
                // Add new messages to particle system
                if (data.messages) {
                    data.messages.forEach(m => {
                        particles.push({
                            src: m.src,
                            dst: m.dst,
                            type: m.type,
                            progress: 0.0
                        });
                    });
                }
            });
        }

        setInterval(updateDashboard, 500);
    </script>

</body>
</html>
